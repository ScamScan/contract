"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportRevertedWithoutReason = void 0;
const utils_1 = require("./utils");
function supportRevertedWithoutReason(Assertion) {
    Assertion.addMethod("revertedWithoutReason", function () {
        const onSuccess = () => {
            this.assert(false, `Expected transaction to be reverted without a reason, but it didn't revert`);
        };
        const onError = (error) => {
            const returnData = (0, utils_1.getReturnDataFromError)(error);
            const decodedReturnData = (0, utils_1.decodeReturnData)(returnData);
            if (decodedReturnData.kind === "Error") {
                this.assert(false, `Expected transaction to be reverted without a reason, but it reverted with reason '${decodedReturnData.reason}'`);
            }
            else if (decodedReturnData.kind === "Empty") {
                this.assert(true, null, "Expected transaction NOT to be reverted without a reason, but it was");
            }
            else if (decodedReturnData.kind === "Panic") {
                this.assert(false, `Expected transaction to be reverted without a reason, but it reverted with panic code ${decodedReturnData.code.toHexString()} (${decodedReturnData.description})`);
            }
            else if (decodedReturnData.kind === "Custom") {
                this.assert(false, `Expected transaction to be reverted without a reason, but it reverted with a custom error`);
            }
            else {
                const _exhaustiveCheck = decodedReturnData;
            }
        };
        const derivedPromise = Promise.resolve(this._obj).then(onSuccess, onError);
        this.then = derivedPromise.then.bind(derivedPromise);
        this.catch = derivedPromise.catch.bind(derivedPromise);
        return this;
    });
}
exports.supportRevertedWithoutReason = supportRevertedWithoutReason;
//# sourceMappingURL=revertedWithoutReason.js.map